<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Flame Dragon — Demo</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:#0b0b0c;color:#eee}
    #app{display:flex;height:100vh;}
    #canvas-wrap{flex:1;position:relative;overflow:hidden}
    canvas{display:block}
    #sidebar{width:320px;background:linear-gradient(180deg,#0f1720,#081018);padding:18px;box-shadow:0 0 40px rgba(0,0,0,0.6);}
    h1{font-size:18px;margin:0 0 12px}
    .control{margin-bottom:12px}
    label{display:block;font-size:13px;margin-bottom:6px;opacity:0.9}
    select,input[type=range]{width:100%}
    .button{display:inline-block;padding:8px 12px;border-radius:8px;background:#ff6b35;color:#fff;text-decoration:none;cursor:pointer;margin-right:8px;border:none}
    footer{position:absolute;left:18px;bottom:18px;color:#888;font-size:12px}
    .small{font-size:12px;color:#bbb}
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h1>Flame Dragon — Selector</h1>
      <p class="small">Choose a dragon body style and tweak flame intensity, color and animation speed. Click & drag in the 3D view to rotate. Scroll to zoom. Use the buttons to export or reset.</p>

      <div class="control">
        <label for="dragonSelect">Dragon type</label>
        <select id="dragonSelect">
          <option value="serpent">Serpent (long & sinuous)</option>
          <option value="wyvern">Wyvern (bulkier, wing hint)</option>
          <option value="spine">Spined (armored look)</option>
        </select>
      </div>

      <div class="control">
        <label for="flameIntensity">Flame intensity <span id="flameVal">0.7</span></label>
        <input id="flameIntensity" type="range" min="0" max="1" step="0.01" value="0.7">
      </div>

      <div class="control">
        <label for="speedRange">Animation speed <span id="speedVal">1.0</span></label>
        <input id="speedRange" type="range" min="0" max="3" step="0.01" value="1">
      </div>

      <div class="control">
        <label for="palette">Color palette</label>
        <select id="palette">
          <option value="classic">Classic (red → yellow)</option>
          <option value="blue">Blue ice-flame</option>
          <option value="green">Toxic green</option>
        </select>
      </div>

      <div class="control">
        <button id="downloadBtn" class="button">Export PNG</button>
        <button id="resetBtn" class="button" style="background:#2b3440">Reset</button>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:14px 0">
      <div class="small">Tip: You can replace the dragon generator with a glTF model (loader included but commented) if you want a high-detail dragon model. This demo uses procedural geometry so it runs without external assets.</div>
    </div>

    <div id="canvas-wrap">
      <canvas id="c"></canvas>
      <footer>Interactive Flame Dragon • Move mouse to rotate • Abdulrehman</footer>
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <script>
  // --- Scene setup ---
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:false});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth - 320, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050507);

  const camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 320)/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 18);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.07;

  // lights
  const amb = new THREE.HemisphereLight(0xffffff, 0x222222, 0.6);
  scene.add(amb);
  const pLight = new THREE.PointLight(0xffaa66, 2, 60);
  pLight.position.set(10,10,10);
  scene.add(pLight);

  // helper ground subtle
  const grid = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0})
  );
  grid.rotation.x = -Math.PI/2; grid.position.y = -6;
  scene.add(grid);

  // --- Shader for flame-like material ---
  const FlameShader = {
    uniforms: {
      time: {value:0},
      intensity: {value:0.7},
      palette: {value:0},
    },
    vertexShader: `
      varying vec3 vPos;
      varying vec2 vUv;
      void main(){
        vUv = uv;
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vPos;
      varying vec2 vUv;
      uniform float time;
      uniform float intensity;
      uniform int palette;

      // simple hash / noise
      float hash(float n){return fract(sin(n)*43758.5453123);} 
      float noise(vec2 x){
        vec2 p = floor(x);
        vec2 f = fract(x);
        f = f*f*(3.0-2.0*f);
        float n = p.x + p.y*57.0;
        float res = mix(mix(hash(n+0.0), hash(n+1.0), f.x), mix(hash(n+57.0), hash(n+58.0), f.x), f.y);
        return res;
      }

      vec3 getPalette(float t){
        if(palette==0){
          return mix(vec3(0.6,0.05,0.02), vec3(1.0,0.9,0.2), t);
        } else if(palette==1){
          return mix(vec3(0.02,0.08,0.6), vec3(0.8,0.9,1.0), t);
        } else {
          return mix(vec3(0.02,0.4,0.05), vec3(0.9,1.0,0.4), t);
        }
      }

      void main(){
        float h = length(vPos.xy);
        float t = vUv.y * 1.5 - time*0.6;
        float n = noise(vec2(vUv.x*4.0 + time*0.8, vUv.y*6.0));
        float flame = smoothstep(0.0, 1.0, (1.0 - vUv.y*1.2) + n*0.6);
        flame = pow(flame, 1.0 - intensity*0.8);
        vec3 col = getPalette(clamp(flame,0.0,1.0));
        // add glow towards tip
        float glow = exp(-h*1.2) * (0.6 + 0.6*flame);
        vec3 outc = col * (0.6 + flame*0.8) + vec3(glow);
        gl_FragColor = vec4(outc, 1.0);
      }
    `
  };

  // container for dragon mesh
  let dragonGroup = new THREE.Group();
  scene.add(dragonGroup);

  // create a tube along a spline and vary parameters per style
  function makeDragonMesh(style){
    const points = [];
    const length = 160;
    const radiusBase = {serpent:0.6, wyvern:1.1, spine:0.9}[style];
    const curl = {serpent:1.6, wyvern:0.9, spine:1.0}[style];

    for(let i=0;i<length;i++){
      const t = i/(length-1);
      const x = (t-0.5)*20;
      const y = Math.sin(t*Math.PI*2.0*curl)*3.0;
      const z = Math.cos(t*3.0)*2.0*t;
      points.push(new THREE.Vector3(x,y, z));
    }
    const spline = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.TubeGeometry(spline, 320, radiusBase, 20, false);

    // add spines for 'spine' style
    if(style==='spine'){
      const pos = geometry.attributes.position;
      const len = pos.count;
      const extra = new Float32Array(len*3);
      for(let i=0;i<len;i++){
        const vx = pos.getX(i), vy = pos.getY(i), vz = pos.getZ(i);
        const offset = Math.sin(vx*2.0 + vy*3.0)*0.6;
        extra[i*3+0] = vx + offset;
        extra[i*3+1] = vy + Math.abs(offset)*0.8 + 0.2;
        extra[i*3+2] = vz;
      }
      // create an extruded silhouette by merging with base geometry
      const spineGeo = geometry.clone();
      spineGeo.translate(0,0.05,0);
      // we'll keep simple: use same geometry but material will show 'spine' by noise
    }

    const material = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(FlameShader.uniforms),
      vertexShader: FlameShader.vertexShader,
      fragmentShader: FlameShader.fragmentShader,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true; mesh.receiveShadow = true;

    // simple head: sphere attached to one end
    const headGeo = new THREE.SphereGeometry(radiusBase*1.4, 24, 18);
    const headMat = material;
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.copy(points[length-1]);
    // small scale to fit
    head.position.multiplyScalar(1.0);

    const group = new THREE.Group();
    group.add(mesh);
    group.add(head);

    return {group, material};
  }

  // current
  let state = {type:'serpent', intensity:0.7, speed:1.0, palette:0};
  let current = null;

  function buildDragon(){
    if(current){ scene.remove(current.group); }
    dragonGroup.clear();
    const {group, material} = makeDragonMesh(state.type);
    current = {group, material};
    group.rotation.y = Math.PI;
    dragonGroup.add(group);
    scene.add(dragonGroup);
  }

  buildDragon();

  // resize
  function onWindowResize(){
    const w = window.innerWidth - 320;
    const h = window.innerHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onWindowResize);

  // UI bindings
  const dragonSelect = document.getElementById('dragonSelect');
  const flameIntensity = document.getElementById('flameIntensity');
  const flameVal = document.getElementById('flameVal');
  const speedRange = document.getElementById('speedRange');
  const speedVal = document.getElementById('speedVal');
  const palette = document.getElementById('palette');
  const downloadBtn = document.getElementById('downloadBtn');
  const resetBtn = document.getElementById('resetBtn');

  dragonSelect.addEventListener('change', ()=>{ state.type = dragonSelect.value; buildDragon(); });
  flameIntensity.addEventListener('input', ()=>{ state.intensity = parseFloat(flameIntensity.value); flameVal.textContent = state.intensity.toFixed(2); if(current) current.material.uniforms.intensity.value = state.intensity; });
  speedRange.addEventListener('input', ()=>{ state.speed = parseFloat(speedRange.value); speedVal.textContent = state.speed.toFixed(2); });
  palette.addEventListener('change', ()=>{ state.palette = ['classic','blue','green'].indexOf(palette.value); if(current) current.material.uniforms.palette.value = state.palette; });

  downloadBtn.addEventListener('click', ()=>{
    renderer.render(scene, camera);
    const url = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'dragon.png'; a.click();
  });
  resetBtn.addEventListener('click', ()=>{ dragonSelect.value='serpent'; flameIntensity.value=0.7; speedRange.value=1; palette.value='classic'; flameVal.textContent='0.7'; speedVal.textContent='1.0'; state={type:'serpent',intensity:0.7,speed:1.0,palette:0}; buildDragon(); });

  // animate
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    if(current){
      current.material.uniforms.time.value = t * state.speed;
      current.material.uniforms.intensity.value = state.intensity;
      current.material.uniforms.palette.value = state.palette;
      // subtle breathing animation
      current.group.children[0].rotation.z = Math.sin(t*0.5)*0.02;
      current.group.children[0].rotation.x = Math.sin(t*0.3)*0.02;
    }
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // initial uniform sync
  setTimeout(()=>{
    if(current) { current.material.uniforms.intensity.value = state.intensity; current.material.uniforms.palette.value = state.palette; }
  }, 50);
  </script>
</body>
</html>
